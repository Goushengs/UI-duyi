循环不变量
循环前、中、后保持不变
「循环不变量」不是很高深的概念，在「算法」和「数据结构」的世界里，到处都有它的身影。

「循环不变量」是指我们在编写代码的过程中，要一直循序不变的性质，这样的性质是根据要解决的问题，由我们自己定义的。「循环不变量」是我们写对一个问题的基础，保证了在「初始化」「循环遍历」「结束」这三个阶段相同的性质，使得一个问题能够被正确解决。

### 例题：删除有序数组中的重复项

给你一个有序数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:


// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
示例 1：


输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：


输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
提示：

0 <= nums.length <= 3 * 10^4
-10^4 <= nums[i] <= 10^4
nums 已按升序排列
思路分析：这个问题并不难，相信大家一定可以独立做出来。我们给出两种写法，两种写法里 i 都是用于遍历的下标，而 j 的含义不同，请大家分别比较两者代码的差异。

定义 1：j 指向马上要赋值的元素的下标，因此我们定义区间 [0..j) （注意是左闭右开区间，j 不能取到）里没有重复元素。pre 永远指向第 1 个不重复的数字；

初始化：为了保证区间 [0..j) （注意这里是左闭右开区间）里没有重复元素。初始的时候，i = 0 ，下标为 0 的位置只有一个数，区间 [0..j) 一定不会出现重复，这件事情表示为区间 [0..0] 没有重复数字，即区间 [0..1) 没有重复数字，因此 j 初始化的时候需要等于 1；
保持：遇到和 pre 指向的数字相等元素，i++ 直接看到下一个元素，如果 nums[i] != pre ，表示程序看到了第 1 个不重复的数字，此时需要赋值 nums[j] = nums[i] 和 pre = nums[j] ，然后让 j++ 指向下一个需要赋值的下标；
终止：循环结束以后 i = len ，程序看完了输入数组的所有元素，此时区间 [0..j) 里没有重复元素，它的长度为 j ，返回 j。

```js
参考代码 1：

Java

public class Solution {

    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }
        int j = 1;
        int pre = nums[0];
        for (int i = 1; i < len; i++) {
            if (nums[i] != pre) {
                nums[j] = nums[i];
                pre = nums[j];
                j++;
            }
        }
        return j;
    }
}
定义 2：我们定义：区间 [0..j] （注意这里是左闭右闭区间）没有出现重复元素，此时变量 j 是上一轮找到的第 1 次出现的元素的下标。因此我们不需要像「定义 1」一样给 pre 定义。循环变量 i 看到的数值 nums[i] 永远和变量 j 看到的数值 nums[j] 进行比较。 大家可以对照上面的「定义 1」自行写出「初始化」「保持」「终止」的逻辑。

参考代码 2：

Java

public class Solution {

    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }
        int j = 0;
        for (int i = 1; i < len; i++) {
            if (nums[i] != nums[j]) {
                j++;
                nums[j] = nums[i];
            }
        }
        return j + 1;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，这里数组的长度是 N， i 和 j 分别最多走 N 步；
空间复杂度：O(1)O(1)。


```

### 删除有序数组中的重复项



### 例题：最长连续递增序列

```js
给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

示例 1：


输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
示例 2：


输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
提示：

0 \le nums.length \le 10^40≤nums.length≤10 
4
 
-10^9 \le nums[i] \le 10^9−10 
9
 ≤nums[i]≤10 
9
 
思路分析：题目要求我们找的子序列是 连续 的，并且子序列里的元素要求 严格单调递增。在遍历的时候，从第 2 个元素开始；

如果当前遍历到的元素比它左边的那一个元素要严格大，「连续递增」的长度就加 11；
否则「连续递增」的起始位置就需要重新开始计算。
我们给出了两版参考代码，分别对应了不同的循环不变量。请大家体会它们的不同。

参考代码 1：


public class Solution {

    public int findLengthOfLCIS(int[] nums) {
        int len = nums.length;
        int res = 0;
        int i = 0;
        int j = 0;
        // 循环不变量 [i..j) 严格单调递增
        while (j < len) {
            if (j > 0 && nums[j - 1] >= nums[j]) {
                i = j;
            }
            j++;
            res = Math.max(res, j - i);
        }
        return res;
    }
}
说明：这一版代码循环不变量为：[i..j) 严格单调递增，初始化的时候 i = 0，j = 0 ，空区间符合严格单调递增的定义。j 左边的元素表示程序已经看到，所以先 j++，计算严格单调递增的区间的长度的时候，长度为 j - i。

参考代码 2：


public class Solution {

    public int findLengthOfLCIS(int[] nums) {
        int len = nums.length;
        int res = 0;
        int i = 0;
        int j = 0;
        // 循环不变量 [i..j] 严格单调递增
        while (j < len) {
            if (j > 0 && nums[j - 1] >= nums[j]) {
                i = j;
            }
            res = Math.max(res, j - i + 1);
            j++;
        }
        return res;
    }
}

说明：这一版代码循环不变量为：[i..j] 严格单调递增，初始化的时候 i = 0，j = 0 ，只有一个元素的区间符合严格单调递增的定义。j 的含义与「参考代码 1」不同，j 以及 j 左边的元素表示程序已经看到，所以先计算区间的长度 j - i + 1，然后 j++。

复杂度分析：

时间复杂度：O(N)O(N)，其中 N 是数组 \textit{nums}nums 的长度，程序需要遍历数组一次；

空间复杂度：O(1)O(1)。额外使用的空间为常数。

```

### 最长连续递增序列

练习：1.移除元素 2. 删除排序数组中的重复项 II   3.移动零

#### 使用循环不变量写对代码

这一节我们讲解两个非常基础且常考的问题，向大家展示：我们在写代码的时候一定要明确自己对变量以及区间的定义是什么，并且在编写代码的过程中保持定义不变。



### 例题：颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

示例 1：


输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
示例 2：


输入：nums = [2,0,1]
输出：[0,1,2]
示例 3：


输入：nums = [0]
输出：[0]
示例 4：


输入：nums = [1]
输出：[1]
提示：

n == nums.length
1 <= n <= 300
nums[i] 为 0、1 或 2
进阶：

你可以不使用代码库中的排序函数来解决这道题吗？
你能想出一个仅使用常数空间的一趟扫描算法吗？

```js
思路分析：解决这道问题需要有快速排序 partition 的知识作为基础。

我们可以在区间上设置两个表示分界的位置，并且定义循环不变量：

所有的元素在区间 [0..zero) = 0；
所有的元素在区间 [zero..i) = 1；
区间 [i..two) 是程序没有看到的部分；
所有的元素在区间 [two..len - 1] = 2，这里 len 表示数组的长度。
这种定义下，为了让初始化的时候三个区间都为空区间，zero = 0，two = len，程序没有看到的部分是整个数组。程序什么时候终止呢？当 i == two 时，三个子区间正好覆盖了整个数组，程序没有看到的部分为空，因此循环可以继续的条件是：i < two 。其它的细节我们放在代码中。

参考代码 1：


import java.util.Arrays;


public class Solution {

    public void sortColors(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return;
        }
        
        int zero = 0;
        int two = len;
        int i = 0;
        while (i < two) {
            if (nums[i] == 0) {
                swap(nums, i, zero);
                zero++;
                i++;
            } else if (nums[i] == 1) {
                i++;
            } else {
                two--;
                swap(nums, i, two);
            }
        }
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，这里 NN 是输入数组的长度；
空间复杂度：O(1)O(1)。
如果我们按照下面这种方式定义循环不变量：

所有的元素在区间 [0..zero] = 0；
所有的元素在区间 (zero..i) = 1；
区间 [i..two] 是程序没有看到的部分；
所有的元素在区间 (two..len - 1] = 2，这里 len 表示数组的长度。
这种定义下，为了让初始化的时候三个区间都为空区间，zero = -1，two = len - 1。程序什么时候终止呢？当 i == two + 1 时，三个子区间正好覆盖了整个数组，因此循环可以继续的条件是：i <= two 。其它的细节我们放在代码中。

参考代码 2：

Java

public class Solution {

    public void sortColors(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return;
        }
        int zero = -1;
        int two = len - 1;
        int i = 0;
        while (i <= two) {
            if (nums[i] == 0) {
                zero++;
                swap(nums, i, zero);
                i++;
            } else if (nums[i] == 1) {
                i++;
            } else {
                swap(nums, i, two);
                two--;
            }
        }
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
复杂度分析：（同「参考代码 1」）。

总结：循环不变量是写对代码、分析边界条件的基础。

在循环变量 i 遍历的过程中，人为定义的循环不变的性质，决定了「初始化」「遍历过程」和「循环终止」条件。初始化的时候，变量的初始值需要保证三个区间为空区间，而循环终止的时候，循环变量 i 需要使得我们定义的三个区间覆盖整个数组。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/rl7myd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 例题：数组中的第 K 个最大元素

```js
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:


输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:


输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
说明:

1 \le k \le nums.length \le 10^41≤k≤nums.length≤10 
4
 

-10^4 \le nums[i] \le 10^4−10 
4
 ≤nums[i]≤10 
4
 

思路分析：这道题可以使用优先队列（堆）完成。我们这里展示另一种使用快速排序 partition 的知识解决的办法。我们给出三种循环不变量的定义，借此问题，大家也可以复习一下快速排序算法。

循环不变量定义 1：把等于切分元素的所有元素分到了数组的同一侧。

我们定义 pivot = nums[left] ，剩下的区间 [left + 1..right] 被变量 le 分成三个部分：

[left + 1 .. le] <= pivot；
(le..i] > pivot；
(i..right] 是程序没有看到的部分。
其它细节我们放在「参考代码 1」中。

参考代码 1：

Java

import java.util.Arrays;
import java.util.Random;

public class Solution {

    private static Random random = new Random(System.currentTimeMillis());

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
				// 第 k 大元素的下标是 len - k
        int target = len - k;

        int left = 0;
        int right = len - 1;
        while (true) {
            int pIndex = partition(nums, left, right);

            if (pIndex == target) {
                return nums[pIndex];
            } else if (pIndex < target) {
                // 下一轮搜索区间 [pIndex + 1..right]
                left = pIndex + 1;
            } else {
                // pIndex > target
                // 下一轮搜索区间 [left..pIndex - 1]
                right = pIndex - 1;
            }
        }

    }

    private int partition(int[] nums, int left, int right) {
        // 注意：必须随机化
        int randomIndex = left + random.nextInt(right - left + 1);
        swap(nums, left, randomIndex);

        int pivot = nums[left];
        // [left + 1 .. le] <= pivot
        // (le..i] > pivot
        // 注意：一定要设置成 left ，否则交换会出错
        int le = left;
        for (int i = left + 1; i <= right; i++) {
            // 这里写 < 或者 <= 都可以
            if (nums[i] <= pivot) {
                le++;
                swap(nums, le, i);
            }
        }

        swap(nums, left, le);
        return le;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」；
空间复杂度：O(\log N)O(logN)，递归使用栈空间的空间代价的期望为 O(\log N)O(logN)。
循环不变量定义 2：把等于切分元素的所有元素 等概率 地分到了数组的两侧，避免了递归树倾斜，递归树相对平衡。

我们定义 pivot = nums[left] ，剩下的区间 [left + 1..right] 被变量 le 、ge 分成三个部分：

[left..le) <= pivot；
[le..ge] 是程序没有看到的部分；
(ge..right] >= pivot。
其它细节我们放在「参考代码 2」中。

参考代码 2：

Java

import java.util.Random;

public class Solution {

    private static Random random = new Random(System.currentTimeMillis());

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int left = 0;
        int right = len - 1;

        // 第 k 大元素的下标是 len - k
        int target = len - k;

        while (true) {
            int index = partition(nums, left, right);
            if (index == target) {
                return nums[index];
            } else if (index < target) {
                left = index + 1;
            } else {
                right = index - 1;
            }
        }
    }

    public int partition(int[] nums, int left, int right) {
        // 在区间随机选择一个元素作为标定点
        int randomIndex = left + random.nextInt(right - left + 1 );
        swap(nums, left, randomIndex);
        

        int pivot = nums[left];

        // 将等于 pivot 的元素分散到两边
        // [left..le) <= pivot
        // (ge..right] >= pivot

        int le = left + 1;
        int ge = right;

        while (true) {
            // 遇到 nums[le] >= pivot 的时候停下来
            // 遇到与 pivot 相等的元素，是通过交换被等概率分到两边的
            while (le <= ge && nums[le] < pivot) {
                le++;
            }
            while (le <= ge && nums[ge] > pivot) {
                ge--;
            }

            if (le > ge) {
                break;
            }
            swap(nums, le, ge);
            le++;
            ge--;
        }

        // 这里还要交换，注意是 ge
        swap(nums, left, ge);
        return ge;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
复杂度分析：（同「参考代码 1」）。

循环不变量定义 3：把等于切分元素的所有元素挤到了数组的中间，在有很多元素和切分元素相等的情况下，递归区间大大减少。

友情提示：这一版代码稍显麻烦，大家了解即可。

我们定义 pivot = nums[left] ，剩下的区间 [left + 1..right] 被变量 lt 、gt 分成四个部分：

[left + 1..lt] < pivot；
[lt + 1..i) = pivot ；
[i..gt) 是程序没有看到的部分；
[gt..right] > pivot。
其它细节我们放在「参考代码 3」中。

参考代码 3：

Java

import java.util.Random;

public class Solution {

    private static Random RANDOM = new Random(System.currentTimeMillis());

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int target = len - k;

        int left = 0;
        int right = len - 1;
        while (true) {
            int[] pIndex = partition(nums, left, right);

            int index1 = pIndex[0];
            int index2 = pIndex[1];

            if (target < index1) {
                // 下一轮搜索区间 [left..index1 - 1]
                right = index1 - 1;
            } else if (target == index1) {
                return nums[index1];
            } else if (target < index2) {
                left = index1 + 1;
                right = index2 - 1;
            } else if (target == index2) {
                return nums[index2];
            } else {
                // pIndex > target
                // 下一轮搜索区间 [index2 + 1..right]
                left = index2 + 1;
            }
        }
    }

    private int[] partition(int[] nums, int left, int right) {
        int randomIndex = left + RANDOM.nextInt(right - left + 1);
        swap(nums, randomIndex, left);

        // 循环不变量：
        // all in [left + 1..lt] < pivot
        // all in [lt + 1..i) = pivot
        // all in [gt..right] > pivot
        int pivot = nums[left];
        int lt = left;
        int gt = right + 1;

        int i = left + 1;
        while (i < gt) {
            if (nums[i] < pivot) {
                lt++;
                swap(nums, i, lt);
                i++;
            } else if (nums[i] == pivot) {
                i++;
            } else {
                gt--;
                swap(nums, i, gt);
            }
        }
        swap(nums, left, lt);
        // 这里要特别小心
        return new int[]{lt, gt - 1};
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
复杂度分析：（同「参考代码 1」）。

```







### 滑动窗口 1：同向交替移动的两个变量

#### 同向交替移动的两个变量

有一类数组上的问题，问我们固定长度的滑动窗口的性质，这一类问题在思维层面上相对简单。我们通过两道简单的例题向大家展示这一类问题的写法。

### 例题：子数组最大平均数 I

给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。

示例：


输入：[1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
提示：

1 <= k <= n <= 30,000。
所给数据范围 [-10,000，10,000]。
思路分析：

我们可以枚举出所有长度为 k 的连续子数组（时间复杂度为 O(N)O(N)），分别求出它们的平均数（时间复杂度为 O(N)O(N)），从中选出最大的平均数。 事实上，相邻的两个长度固定的连续子数组，它们有一部分是重合的，在计算平均数的时候可以不用遍历。

![1696684015888](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684015888.png)

由于窗口的长度固定，我们可以计算出所有的长度固定的连续子数组的和，在这些和中求出最大值，除以 kk，就是题目要求的最大平均值

![1696684038174](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684038174.png)

![1696684053781](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684053781.png)

![1696684067716](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684067716.png)

![1696684082406](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684082406.png)

![1696684094079](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684094079.png)

![1696684110918](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684110918.png)

参考代码：


public class Solution {

    public double findMaxAverage(int[] nums, int k) {
        int len = nums.length;
        // 由于题目限制了 k <= len，因此不用做特判
        int windowSum = 0;
        // 第 1 步：先求出第 1 个窗口的和
      	for (int i = 0; i < k; i++) {
            windowSum += nums[i];
        }
    
      	// 第 2 步：通过遍历求出除了第 1 个窗口的和
        int res = windowSum;
        // 循环不变量定义：[left..right) 是长度为 k 的窗口
        for (int right = k; right < len; right++) {
            // 加上一个数再减去一个数
            windowSum = windowSum + nums[right] - nums[right - k];
            res = Math.max(res, windowSum);
        }
        return (double) res / k;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，其中 NN 是数组 \textit{nums}nums 的长度。我们的算法遍历了数组一次。
空间复杂度：O(1)O(1)。

### 例题：爱生气的书店老板

今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。

在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。

书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。

请你返回这一天营业下来，最多有多少客户能够感到满意的数量。

示例：


输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
输出：16
解释：
书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
提示：

1 <= X <= customers.length == grumpy.length <= 20000
0 <= customers[i] <= 1000
0 <= grumpy[i] <= 1
思路分析：

如果 grumpy[i] = 0 表示在这个时刻进店的顾客本来就是满意的。书店老板即使发动技能，这部分的顾客也不会因此受到影响。那么真正受到影响的就是 grumpy[i] = 1 的那些顾客，因此：

能够满意的客户数量 = 老板是不是发动技能都满意的客户数量 + 老板发动技能可以让顾客满意的数量
其中老板发动技能可以让顾客满意的数量就是那些 grumpy[i] = 1 的那些顾客，为了求得这部分的区间和，我们可以使用「前缀和」技巧：输入数组区间 preSum[i] 表示 [0..i) 的和，区间 [i..j] 的和可以使用 preSum[j] - preSum[i - 1] ，请大家重点体会我们的定义为什么 preSum[i] 是左闭右开的，且为什么要数组开 len + 1 长度。

![1696684157557](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684157557.png)

![1696684173677](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684173677.png)

![1696684190764](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684190764.png)

![1696684211582](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684211582.png)

![1696684229885](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684229885.png)

![1696684251348](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684251348.png)

![1696684265189](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684265189.png)

![1696684278751](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684278751.png)

![1696684295566](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684295566.png)

参考代码：


public class Solution {

    public int maxSatisfied(int[] customers, int[] grumpy, int X) {
        int len = grumpy.length;
        // 前缀和 preSum[i] 表示 [0..i) 里因为老板生气而感到不开心的顾客数
        int[] preSum = new int[len + 1];
    
        // 统计 1. 所有本来就不生气的顾客数量；2. 前缀和数组
        int originCount = 0;
        for (int i = 0; i < len; i++) {
            if (grumpy[i] == 0) {
                // 不生气
                originCount += customers[i];
                preSum[i + 1] = preSum[i];
            } else {
                // 生气时候前缀和
                preSum[i + 1] = preSum[i] + customers[i];
            }
        }
    
        int maxAngryCount = 0;
        // 固定长度的滑动窗口的左边界：[i..i + X)
        for (int left = 0; left < len - X + 1; left++) {
            maxAngryCount = Math.max(maxAngryCount, preSum[left + X] - preSum[left]);
        }
        // 所有本来就不生气的顾客
        return originCount + maxAngryCount;
    }
}
说明：参考代码中有一些细节和边界的地方需要大家仔细体会。

复杂度分析：

时间复杂度：O(N)O(N)，其中 nn 是数组 \textit{customers}customers 和 \textit{grumpy}grumpy 的长度。需要对两个数组各遍历两次。
空间复杂度：O(1)O(1)。

练习：1.可获得的最大点数  2.定长子串中元音的最大数目3.将 x 减到 0 的最小操作数

### 滑动窗口 2：不定长度的滑动窗口

有一类数组上的问题，需要使用两个指针变量（我们称为左指针和右指针），同向、交替向右移动完成任务。这样的过程像极了一个窗口在平面上滑动的过程，因此我们将解决这一类问题的算法称为「滑动窗口」问题。

掌握好这一类「滑动窗口」的问题，需要先从「暴力解法」开始分析，「滑动窗口」利用了问题本身的特点，在两个指针同向、交替向右移动的过程中，少考虑了很多「暴力解法」需要考察了情况，将时间复杂度降到了线性级别 O(N)O(N)（这里 NN 是数组的长度），如下图所示。

![1696684407764](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684407764.png)

写对「滑动窗口」除了要弄清楚为什么可以使用滑动窗口，还需要明白代码编写过程中的「循环不变量」，这样才不会在初始化和一些边界问题上出错。我们会在例题讲解的部分和大家进行说明。

### 例题：最小覆盖子串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

示例 1：


输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：


输入：s = "a", t = "a"
输出："a"
提示：

1 <= s.length, t.length <= 105
s 和 t 由英文字母组成

方法一：暴力求解
以 输入: S = "ADOBECODEBANC", T = "ABC" 为例，由于 T 中所有的字符都互不相同。我们可以：

枚举 S 中长度大于等于 3 的所有子串；
对这些子串逐个判断是否包含 T 的所有字母；
对满足上述两条的所有子串，取最小值。
枚举所有子串，O(N^2)O(N 
2
 ) ，判断是否包含 T 的所有字符，O(N)O(N)。总体的时间复杂度是 O(N^3)O(N 
3
 )。下面我们思考如何优化。

方法二：滑动窗口
一开始的时候，left 和 right 都位于下标 0 的位置。right 向右移动，直至包含 T 的所有字母。由于我们要求的是最小子串，因此，以 left 开头的子串 [left..right + 1]、 [left..right + 2]、……、 [left..len - 1] 一定不符合要求，因此这些区间可以不用判断；
然后考虑 left 如何移动。此时 left 不能向左移动，向左移动只能让子串更长，我们要求最小子串，因此 left 只能右移，移到恰恰好 [left..right] 区间里面的字符不包含 T 所有字母的最小子串；
然后 right 继续向右移动，直到包含 T 所有字母的最小子串。
重复这样的过程，直到 right 到达 S 的末尾。怎么样，这个思想是不是和第 3 题是一样的，尺取法。

「滑动窗口」算法有下面的特点：

right 先向右移动，移到不能再移动的时候，left 再向右移动；
right 右移使得滑动窗口边长，刚好满足条件，left 右移使得滑动窗口变短到刚好不满足条件，然后 right 变长刚好满足条件，如此循环下去，直到 right 到达末尾。这里的条件是指：[left, right) 包含 T 所有字母。
那么如何判断区间 [left, right] 内包含 T 所有字母呢？由于我们并不关心字母的顺序，因此我们采用的是对比频数数组的方式。

先对 T 做频数统计，然后设置一个变量 distance 表示 T 中一共有多少个不同的字母；
left 和 right 在动的时候，只对 T 中出现的字母做统计；
right 移动的时候，频数增加，加到刚刚好和 T 对应字母相等的时候，distance - 1，表示滑动窗口内的字母种类与 T 的差距减少了 1，当这个差距为 0 的时候，滑动窗口内包含 T 所有字母的最小子串。此时考虑移动 left；
left 移动的时候，做减法，减少到刚刚好比 T 中对应字符个数少 1 的时候，就说明「平衡」被打破，此时应该 right 继续向右移动。
参考代码：

Java

public class Solution {

    public String minWindow(String s, String t) {
        int[] window = new int[128];
        int[] pattern = new int[128];
    
        final int A = 'A';
    
        for (Character c : t.toCharArray()) {
            pattern[c - A]++;
        }
        int distance = 0;
    
        for (int i = 0; i < 128; i++) {
            if (pattern[i] > 0) {
                distance++;
            }
        }
    
        int sLen = s.length();
        int start = 0;
        int left = 0;
        int right = 0;
        int match = 0;
        int minLen = sLen + 1;
    
        while (right < sLen) {
            Character curChar = s.charAt(right);
            if (pattern[curChar - A] > 0) {
                window[curChar - A]++;
    
                if (window[curChar - A] == pattern[curChar - A]) {
                    match++;
                }
            }
    
            right++;
    
            while (match == distance) {
                if (right - left < minLen) {
                    start = left;
                    minLen = right - left;
                }
    
                // 考虑左边界向右边走
                Character leftChar = s.charAt(left);
                if (pattern[leftChar - A] > 0) {
                    window[leftChar - A]--;
    
                    if (window[leftChar - A] < pattern[leftChar - A]) {
                        match--;
                    }
                }
                left++;
            }
        }
        return minLen == sLen + 1 ? "" : s.substring(start, start + minLen);
    }
}
细节：

minLen，一开始要设置一个不可能的值；
同时记录左边界 left 和 minLen。
复杂度分析：

时间复杂度：O(|S| + |T|)O(∣S∣+∣T∣)，这里 |S|∣S∣ 表示字符串 S 的长度，这里 |T|∣T∣ 表示字符串 T 的长度；
空间复杂度：O(|S| + |T|)O(∣S∣+∣T∣)，只使用到常数个变量。

### 例题：替换后的最长重复字符

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

注意：字符串长度 和 k 不会超过 10^410 
4
 。

示例 1：


输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
示例 2：


输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。

文字解析
如果一个问题暂时没有思路，可以先考虑暴力解法（不一定要实现）。当前问题的暴力解法是：枚举输入字符串的 所有 子串，对于每一个子串：

如果子串里所有的字符都一样，就考虑长度更长的子串；
如果当前子串里出现了至少两种字符，要想使得替换以后所有的字符都一样，并且重复的、连续的部分更长，应该替换掉出现次数最多字符 以外 的字符。
暴力解法的时间复杂度为 O(N^3)O(N 
3
 )（这里 NN 是输入字符串的长度，枚举所有子串 O(N^2)O(N 
2
 )，对于每一个子串计算最多出现的字符 O(N)O(N)）。而题目的提示告诉我们字符串长度和 k 不会超过 10^410 
4
 ，暴力算法在这个数据规模下会超时。

暴力解法的缺点：

做了重复的工作，子串和子串有很多重合的部分，重复扫描它们是不划算的；
做了很多没有必要的工作：
如果找到了一个长度为 L 且替换 k 个字符以后全部相等的子串，就没有必要考虑长度小于等于 L 的子串，因为题目只让我们找到符合题意的最长的长度；
如果找到了一个长度为 L 且替换 k 个字符以后不能全部相等的子串，左边界相同、长度更长的子串一定不符合要求（原因我们放在最后说）。
优化暴力解法，我们须要研究一些典型的例子并结合题意找到思路。

以 s = AABCABBB，k = 2 为例，寻找替换 k 次以后字符全部相等的最长子串的长度的过程如下图所示：

![1696684517222](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684517222.png)

![1696684528708](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684528708.png)

![1696684543139](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684543139.png)

![1696684555181](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684555181.png)

![1696684566389](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684566389.png)

![1696684580358](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684580358.png)

![1696684595071](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684595071.png)

![1696684607430](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684607430.png)

![1696684620062](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684620062.png)

![1696684633076](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684633076.png)

![1696684646700](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696684646700.png)

整个过程，我们使用了两个表示边界的变量，一前一后，交替在字符串上前进：右边界先向右和移动，直到它不能移动了为止，左边界再继续向右移动，整个过程像极了一个滑动的窗口在一条线段上移动。

我们还一直关心的是：考虑的子串中最多出现的字符是次数，因此须要一个频数数组，记录每个字符出现的次数。

方法：双指针（滑动窗口）
右边界先移动找到一个满足题意的可以替换 k 个字符以后，所有字符都变成一样的当前看来最长的子串，直到右边界纳入一个字符以后，不能满足的时候停下；
然后考虑左边界向右移动，左边界只须要向右移动一格以后，右边界就又可以开始向右移动了，继续尝试找到更长的目标子串；
替换后的最长重复子串就产生在右边界、左边界交替向右移动的过程中。
友情提示：建议大家先自己尝试编码实现，然后提交验证代码的正确性，并且思考清楚代码中的一些细节，相信会是一个非常不错的练习。

参考代码：

Java

public class Solution {

    public int characterReplacement(String s, int k) {
        int len = s.length();
        if (len < 2) {
            return len;
        }
    
        char[] charArray = s.toCharArray();
        int left = 0;
        int right = 0;
    
        int res = 0;
        int maxCount = 0;
        int[] freq = new int[26];
        // [left, right) 内最多替换 k 个字符可以得到只有一种字符的子串
        while (right < len){
            freq[charArray[right] - 'A']++;
            // 在这里维护 maxCount，因为每一次右边界读入一个字符，字符频数增加，才会使得 maxCount 增加
            maxCount = Math.max(maxCount, freq[charArray[right] - 'A']);
            right++;
    
            if (right - left > maxCount + k){
              	// 说明此时 k 不够用
                // 把其它不是最多出现的字符替换以后，都不能填满这个滑动的窗口，这个时候须要考虑左边界向右移动
                // 移出滑动窗口的时候，频数数组须要相应地做减法
                freq[charArray[left] - 'A']--;
                left++;
            }
            res = Math.max(res, right - left);
        }
        return res;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，这里 NN 是输入字符串 S 的长度；
空间复杂度：O(A)O(A)，这里 AA 是输入字符串 S 出现的字符 ASCII 值的范围。
以下是我们在编码的过程中思考的一些问题。我们建议大家先思考，通过调试，理解代码结果正确的原因。欢迎大家参与讨论。

1. 证明：如果长度为 L 的子串不符合题目的要求，那么左边界固定，长度更长的子串也不符合题目的要求。
答：记 count(X)count(X) 表示长度为 L 的子串中，字符 X 出现的次数。

不失一般性，假设长度为 L 的子串，出现最多的字符为 A，记 count(A) = xcount(A)=x。其余字符均为 B，记 count(B) = ycount(B)=y。由字符 A 出现次数最多，可知 x \ge yx≥y。又由于长度为 L 的子串不符合题目的要求，可知 y > ky>k。起点固定的情况下，考虑更长的子串：

如果接下来看到的字符都是 A（频数最多的字符越来越多），依然须要考虑把之前看到的 B 全部替换成为 A，由于 count(B) = y > kcount(B)=y>k，这是不能做到的；
如果接下来看到的字符不是 A（频数较少的字符超过原来频数最多的字符），那么须要考虑把之前看到的 A 全部替换成为新的频数最多的字符，由于 count(A) = x \ge y > kcount(A)=x≥y>k，这也是不能做到的。
说明：这里我们只讨论了滑动窗口扫过的子区间只含有 2 种字符的情况，如果滑动窗口扫过的子区间只含有 3 种以及 3 种以上字符，讨论是类似的。

2. maxCount 在内层循环「左边界向右移动一个位置」的过程中，没有维护它的定义，结论是否正确？
答：结论依然正确。「左边界向右移动一个位置」的时候，maxCount 或者不变，或者值减 11。

maxCount 的值虽然不维护，但数组 freq 的值是被正确维护的；
当「左边界向右移动」之前：
如果有两种字符长度相等，左边界向右移动不改变 maxCount 的值。例如 s = [AAABBB]、k = 2，左边界 A 移除以后，窗口内字符出现次数不变，依然为 33；
如果左边界移除以后，使得此时 maxCount 的值变小，又由于 我们要找的只是最长替换 k 次以后重复子串的长度。接下来我们继续让右边界向右移动一格，有两种情况：① 右边界如果读到了刚才移出左边界的字符，恰好 maxCount 的值被正确维护；② 右边界如果读到了不是刚才移出左边界的字符，新的子串要想在符合题意的条件下变得更长，maxCount 一定要比之前的值还要更多，因此不会错过更优的解。
3. 内层循环里的 if 能不能改成 while?
答：可以但没有必要。理由依然是：我们只关心最长替换 k 次以后重复子串的长度。

正是因为多读了一个字符，使得 right - left > maxCount + k 成立；
在 left++ 以后，由于可以不维护 maxCount 的定义，right - left > maxCount + k 不成立。因此 if 里面的代码块只会被执行一次。
4. 可以不用一直用 res 记录滑动窗口的最大长度，最后返回 right - left 即可。
答：依然是 我们只关心最长替换 k 次以后重复子串的长度，并且 maxCount 只会增加不会减少。在退出内层 if 语句的时候，区间 [left, right) 不一定是符合要求的子串，但是子串的长度一定等于题目要求的替换 k 次以后字符全都相等的最长子串（maxCount 的值不会变小，所以它会一直撑着滑动窗口的长度直到 right 遍历到字符串的末尾）。这一点如果很难理解的话，我们建议大家使用小测试数据、跟踪代码进行理解。

练习：基础   1.无重复字符的最长子串 2.长度最小的子数组 3.删除子数组的最大得分4.找到字符串中所有字母异位词  5.字符串的排列 6.最大连续1的个数 II 7.最大连续 1 的个数 III 8.尽可能使字符串相等 9.删掉一个元素以后全为 1 的最长子数组  10.爱生气的书店老板  11.最长湍流子数组

进阶：1.K 连续位的最小翻转次数 2.最小窗口子序列 3.长度为 K 的无重复字符子串4.最少交换次数来组合所有的 1 5.健身计划评估

### 滑动窗口 3：计数问题选讲

### 例题：至多包含两个不同字符的最长子串

给定一个字符串 s，找出 至多 包含两个不同字符的最长子串 t ，并返回该子串的长度。

示例 1:


输入: "eceba"
输出: 3
解释: t 是 "ece"，长度为3。
示例 2:


输入: "ccaabbb"
输出: 5
解释: t 是 "aabbb"，长度为5。
说明：

1 \le s.length \le 10^41≤s.length≤10 
4

s 只包含英文字母
思路分析：

如果一个字符串的子串至多包含 3 个不同字符，那么左端点相同，且长度更长的子串一定不是我们要找的子串，此时应该让左端点右移，好让子串至多包含 2 个不同字符；
然后尝试让右边界右移，直到一个字符串的子串至多包含 3 个不同的字符的时候停下。
以上两个步骤交替进行，具体细节请见参考代码。

参考代码：

Java

public class Solution {

    public int lengthOfLongestSubstringTwoDistinct(String s) {
        int len = s.length();
        if (len < 3) {
            return len;
        }
    
        char[] charArray = s.toCharArray();
        int[] freq = new int[128];
        // 滑动窗口里不同字符的个数
        int count = 0;
    
        int res = 2;
        int left = 0;
        int right = 0;
        while (right < len) {
            freq[charArray[right]]++;
            if (freq[charArray[right]] == 1) {
                count++;
            }
            right++;
    
            while (count == 3) {
                freq[charArray[left]]--;
                if (freq[charArray[left]] == 0) {
                    count--;
                }
                left++;
            }
            // 退出循环以后有 count = 2，因此在这里选出最大值
            res = Math.max(res, right - left);
        }
        return res;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，这里 N 是输入字符串的长度；
空间复杂度：O(\Sigma)O(Σ)，频数数组的长度取决于输入字符串里字符的种类个数。
思考：

写完代码以后，请大家思考：

为什么 res = Math.max(res, right - left); 这一行代码要写在退出循环 while (count > 2) 以后的位置；
并且为什么记录滑动窗口的长度表达式为 right - left。

### 例题：至多包含 K 个不同字符的最长子串

给定一个字符串 s，找出 至多 包含 k 个不同字符的最长子串 T。

示例 1:


输入: s = "eceba", k = 2
输出: 3
解释: 则 T 为 "ece"，所以长度为 3。
示例 2:


输入: s = "aa", k = 1
输出: 2
解释: 则 T 为 "aa"，所以长度为 2。
说明：

1 \le s.length \le 5 * 10^41≤s.length≤5∗10 
4

0 \le k \le 500≤k≤50
思路分析：

这道题与「力扣」第 159 题类似，只需要把 22 改成 k 就可以了，其它一样。

参考代码：

Java

public class Solution {

    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        int len = s.length();
        if (len <= k) {
            return len;
        }
    
        char[] charArray = s.toCharArray();
        int[] freq = new int[128];
        int count = 0;
    
        int left = 0;
        int right = 0;
        int res = k;
        while (right < len) {
            freq[charArray[right]]++;
            if (freq[charArray[right]] == 1) {
                count++;
            }
            right++;
    
            while (count == k + 1) {
                freq[charArray[left]]--;
                if (freq[charArray[left]] == 0) {
                    count--;
                }
                left++;
            }
    
            res = Math.max(res, right - left);
        }
        return res;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，这里 N 是输入字符串的长度；
空间复杂度：O(\Sigma)O(Σ)，频数数组的长度取决于输入字符串里字符的种类个数。

### 例题：区间子数组个数

给定一个元素都是正整数的数组A ，正整数 L 以及 R (L <= R)。

求连续、非空且其中最大元素满足大于等于L 小于等于R的子数组个数。


例如 :
输入: 
A = [2, 1, 4, 3]
L = 2
R = 3
输出: 3
解释: 满足条件的子数组: [2], [2, 1], [3].
注意:

L, R 和 A[i] 都是整数，范围在 [0, 10^9]。
数组 A 的长度范围在[1, 50000]。
思路分析：暴力解法需要枚举所有子数组，然后遍历所有子数组，计算最大元素大于等于L 小于等于R的连续子数组个数，时间复杂度为 O(N^3)O(N 
3
 )，这里 NN 是输入数组的长度。

事实上，最大元素在区间 [L..R][L..R] 里的连续子数组的个数，可以看成是一个「区间」的问题，处理区间的问题可以按照「前缀和」的思路。把原问题转化成为「最大元素小于等于 RR 的连续子数组的个数」减去「最大元素小于等于 L - 1L−1 的连续子数组的个数」。

而「最大元素小于等于 XX 的连续子数组的个数」可以使用滑动窗口算法完成，这是因为一旦我们遍历到某个元素的值严格大于 XX，计算「小于等于 XX 的连续子数组的个数」就不能包括这个严格大于 XX 的元素。

因此「最大元素小于等于 XX 的连续子数组的个数」就等于「最大元素小于等于 XX 的连续子数组」的长度之和。我们枚举这些区间的时候可以固定左端点。例如，子区间 [4, 6, 2, 8 ][4,6,2,8] 里的所有元素都小于等于 88，最大元素小于等于 88 的连续子数组的个数就为 [4][4]、[4,6][4,6] 、[4,6,8][4,6,8] 、[4,6,8,10][4,6,8,10] ，这些区间都以左端点 44 开头。

统一枚举的标准才能做到不重不漏。

参考代码：

Java

public class Solution {

    public int numSubarrayBoundedMax(int[] nums, int left, int right) {
        return lessEqualsThan(nums, right) - lessEqualsThan(nums, left - 1);
    }
    
    private int lessEqualsThan(int[] nums, int k) {
        int len = nums.length;
        int res = 0;
        // 循环不变量：nums[left..right] 里的所有元素都小于等于 k
        for (int left = 0, right = 0; right < len; right++) {
            if (nums[right] > k) {
                left = right + 1;
            }
            res += right - left;
        }
        return res;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，其中 NN 是输入数组 nums 的长度；
空间复杂度：O(1)O(1)。

### 例题：K 个不同整数的子数组

最初直觉使用双指针算法遇到的问题
对于一个固定的左边界来说，满足「恰好存在 K 个不同整数的子区间」的右边界 不唯一，且形成区间。

示例 1：左边界固定的时候，恰好存在 22 个不同整数的子区间为 [1,2],[1,2,1],[1,2,1,2][1,2],[1,2,1],[1,2,1,2] ，总数为 33。其值为下标 3 - 1 + 13−1+1，即区间 [1..3][1..3] 的长度。

![1696685012959](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685012959.png)

我们需要找到左边界固定的情况下，满足「恰好存在 K 个不同整数的子区间」最小右边界和最大右边界。

把原问题转换成为容易求解的问题
友情提示：这里把 「恰好」 转换成为 「最多」需要一点求解「双指针（滑动窗口）」问题的经验。建立在熟练掌握这一类问题求解思路的基础上。

把「恰好」改成「最多」就可以使用双指针一前一后交替向右的方法完成，这是因为 对于每一个确定的左边界，最多包含 KK 种不同整数的右边界是唯一确定的，并且在左边界向右移动的过程中，右边界或者在原来的地方，或者在原来地方的右边。

而「最多存在 KK 个不同整数的子区间的个数」与「恰好存在 K 个不同整数的子区间的个数」的差恰好等于「最多存在 K - 1K−1 个不同整数的子区间的个数」。

![1696685040053](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685040053.png)

因为原问题就转换成为求解「最多存在 KK 个不同整数的子区间的个数」与 「最多存在 K - 1K−1 个不同整数的子区间的个数」，它们其实是一个问题。

实现函数 atMostWithKDistinct(A, K) ，表示「最多存在 KK 个不同整数的子区间的个数」。于是 atMostWithKDistinct(A, K) - atMostWithKDistinct(A, K - 1) 即为所求。

参考代码：

Java

public class Solution {

    public int subarraysWithKDistinct(int[] A, int K) {
        return atMostKDistinct(A, K) - atMostKDistinct(A, K - 1);
    }
    
    /**
     * @param A
     * @param K
     * @return 最多包含 K 个不同整数的子区间的个数
     */
    private int atMostKDistinct(int[] A, int K) {
        int len = A.length;
        int[] freq = new int[len + 1];
    
        int left = 0;
        int right = 0;
        // [left, right) 里不同整数的个数
        int count = 0;
        int res = 0;
        // [left, right) 包含不同整数的个数小于等于 K
        while (right < len) {
            if (freq[A[right]] == 0) {
                count++;
            }
            freq[A[right]]++;
            right++;
    
            while (count > K) {
                freq[A[left]]--;
                if (freq[A[left]] == 0) {
                    count--;
                }
                left++;
            }
            // [left, right) 区间的长度就是对结果的贡献
            res += right - left;
        }
        return res;
    }
}
说明： res += right - left; 这行代码的意思：

用具体的例子理解：最多包含 3 种不同整数的子区间 [1, 3, 2, 3] （双指针算法是在左边界固定的前提下，让右边界走到最右边），当前可以确定 1 开始的满足最多包含 3 种不同整数的子区间有 [1]、[1, 3]、[1, 3, 2]、[1, 3, 2, 3]。

所有的 左边界固定前提下，根据右边界最右的下标，计算出来的子区间的个数就是整个函数要返回的值。用右边界固定的前提下，左边界最左边的下标去计算也是完全可以的。

复杂度分析：

时间复杂度：O(N)O(N)，这里 NN 是输入数组的长度；
空间复杂度：O(N)O(N)，使用了常数个变量、频数数组的长度为 N + 1N+1。

练习：1.乘积小于 K 的子数组 2.水果成篮 3.包含所有三种字符的子字符串数目 4.环绕字符串中唯一的子字符串5.找出第 k 小的距离对

### 滑动窗口 4：使用数据结构维护窗口性质

 有一类问题只是名字上叫「滑动窗口」，但解决这一类问题需要用到常见的数据结构。这一节给出的问题可以当做例题进行学习，一些比较复杂的问题是基于这些问题衍生出来的。 

### 例题：滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：

![1696685267454](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685267454.png)



滑动窗口的位置                最大值

---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

示例 2：


输入：nums = [1], k = 1
输出：[1]
示例 3：


输入：nums = [1,-1], k = 1
输出：[1,-1]
示例 4：


输入：nums = [9,11], k = 2
输出：[11]
示例 5：


输入：nums = [4,-2], k = 2
输出：[4]
提示：

1 \le nums.length \le 10^51≤nums.length≤10 
5

-10^4 \le nums[i] \le 104−10 
4
 ≤nums[i]≤104
1 \le k \le nums.length1≤k≤nums.length
前言
对于每个滑动窗口，我们可以使用 O(k)O(k) 的时间遍历其中的每一个元素，找出其中的最大值。对于长度为 nn 的数组 \textit{nums}nums 而言，窗口的数量为 n-k+1n−k+1，因此该算法的时间复杂度为 O((n-k+1)k)=O(nk)O((n−k+1)k)=O(nk)，会超出时间限制，因此我们需要进行一些优化。

我们可以想到，对于两个相邻（只差了一个位置）的滑动窗口，它们共用着 k-1k−1 个元素，而只有 11 个元素是变化的。我们可以根据这个特点进行优化。

方法一：优先队列
思路与算法

对于「最大值」，我们可以想到一种非常合适的数据结构，那就是优先队列（堆），其中的大根堆可以帮助我们实时维护一系列元素中的最大值。

对于本题而言，初始时，我们将数组 \textit{nums}nums 的前 kk 个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 \textit{nums}nums 中的位置出现在滑动窗口左边界的左侧。因此，当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除。

我们不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。为了方便判断堆顶元素与滑动窗口的位置关系，我们可以在优先队列中存储二元组 (\textit{num}, \textit{index})(num,index)，表示元素 \textit{num}num 在数组中的下标为 \textit{index}index。

代码

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });
        for (int i = 0; i < k; ++i) {
            pq.offer(new int[]{nums[i], i});
        }
        int[] ans = new int[n - k + 1];
        ans[0] = pq.peek()[0];
        for (int i = k; i < n; ++i) {
            pq.offer(new int[]{nums[i], i});
            while (pq.peek()[1] <= i - k) {
                pq.poll();
            }
            ans[i - k + 1] = pq.peek()[0];
        }
        return ans;
    }
}

复杂度分析

时间复杂度：O(n \log n)O(nlogn)，其中 nn 是数组 \textit{nums}nums 的长度。在最坏情况下，数组 \textit{nums}nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(\log n)O(logn)，因此总时间复杂度为 O(n \log n)O(nlogn)。

空间复杂度：O(n)O(n)，即为优先队列需要使用的空间。这里所有的空间复杂度分析都不考虑返回的答案需要的 O(n)O(n) 空间，只计算额外的空间使用。

方法二：单调队列
思路与算法

我们可以顺着方法一的思路继续进行优化。

由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 ii 和 jj，其中 ii 在 jj 的左侧（i < ji<j），并且 ii 对应的元素不大于 jj 对应的元素（\textit{nums}[i] \leq \textit{nums}[j]nums[i]≤nums[j]），那么会发生什么呢？

当滑动窗口向右移动时，只要 ii 还在窗口中，那么 jj 一定也还在窗口中，这是 ii 在 jj 的左侧所保证的。因此，由于 \textit{nums}[j]nums[j] 的存在，\textit{nums}[i]nums[i] 一定不会是滑动窗口中的最大值了，我们可以将 \textit{nums}[i]nums[i] 永久地移除。

因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 \textit{nums}nums 中对应的值是严格单调递减的。因为如果队列中有两个相邻的下标，它们对应的值相等或者递增，那么令前者为 ii，后者为 jj，就对应了上面所说的情况，即 \textit{nums}[i]nums[i] 会被移除，这就产生了矛盾。

当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。

由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。

为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。

代码

```
var maxSlidingWindow = function(nums, k) {
    const n = nums.length;
    const q = [];
    for (let i = 0; i < k; i++) {
        while (q.length && nums[i] >= nums[q[q.length - 1]]) {
            q.pop();
        }
        q.push(i);
    }

    const ans = [nums[q[0]]];
    for (let i = k; i < n; i++) {
        while (q.length && nums[i] >= nums[q[q.length - 1]]) {
            q.pop();
        }
        q.push(i);
        while (q[0] <= i - k) {
            q.shift();
        }
        ans.push(nums[q[0]]);
    }
    return ans;
};
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{nums}nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)O(n)。

空间复杂度：O(k)O(k)。与方法一不同的是，在方法二中我们使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k+1k+1 个元素，因此队列使用的空间为 O(k)O(k)。

### 例题：滑动窗口中位数

中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

[2,3,4]，中位数是 3
[2,3]，中位数是 (2 + 3) / 2 = 2.5
给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

示例：

给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。

![1696685299099](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685299099.png)

因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。

提示：

你可以假设 k 始终有效，即：k 始终小于等于输入的非空数组的元素个数。
与真实值误差在 10^{ -5}10 
−5
  以内的答案将被视作正确答案。
前言
本题是「295. 数据流的中位数」的进阶版本。

我们首先思考一下完成本题需要做哪些事情：

初始时，我们需要将数组 \textit{nums}nums 中的前 kk 个元素放入一个滑动窗口，并且求出它们的中位数；

随后滑动窗口会向右进行移动。每一次移动后，会将一个新的元素放入滑动窗口，并且将一个旧的元素移出滑动窗口，最后再求出它们的中位数。

因此，我们需要设计一个「数据结构」，用来维护滑动窗口，并且需要提供如下的三个接口：

\texttt{insert(num)}insert(num)：将一个数 \textit{num}num 加入数据结构；

\texttt{erase(num)}erase(num)：将一个数 \textit{num}num 移出数据结构；

\texttt{getMedian()}getMedian()：返回当前数据结构中所有数的中位数。

方法一：双优先队列 + 延迟删除
思路与算法

我们可以使用两个优先队列（堆）维护所有的元素，第一个优先队列 \textit{small}small 是一个大根堆，它负责维护所有元素中较小的那一半；第二个优先队列 \textit{large}large 是一个小根堆，它负责维护所有元素中较大的那一半。具体地，如果当前需要维护的元素个数为 xx，那么 \textit{small}small 中维护了 \lceil \frac{x}{2} \rceil⌈ 
2
x

 ⌉ 个元素，\textit{large}large 中维护了 \lfloor \frac{x}{2} \rfloor⌊ 
2
x

 ⌋ 个元素，其中 \lceil y \rceil⌈y⌉ 和 \lfloor y \rfloor⌊y⌋ 分别表示将 yy 向上取整和向下取整。也就是说：

\textit{small}small 中的元素个数要么与 \textit{large}large 中的元素个数相同，要么比 \textit{large}large 中的元素个数恰好多 11 个。

这样设计的好处在于：当二者包含的元素个数相同时，它们各自的堆顶元素的平均值即为中位数；而当 \textit{small}small 包含的元素多了一个时，\textit{small}small 的堆顶元素即为中位数。这样 \texttt{getMedian()}getMedian() 就设计完成了。

而对于 \texttt{insert(num)}insert(num) 而言，如果当前两个优先队列都为空，那么根据元素个数的要求，我们必须将这个元素加入 \textit{small}small；如果 \textit{small}small 非空（显然不会存在 \textit{small}small 空而 \textit{large}large 非空的情况），我们就可以将 \textit{num}num 与 \textit{small}small 的堆顶元素 \textit{top}top 比较：

如果 \textit{num} \leq \textit{top}num≤top，我们就将其加入 \textit{small}small 中；

如果 \textit{num} > \textit{top}num>top，我们就将其加入 \textit{large}large 中。

在成功地加入元素 \textit{num}num 之后，两个优先队列的元素个数可能会变得不符合要求。由于我们只加入了一个元素，那么不符合要求的情况只能是下面的二者之一：

\textit{small}small 比 \textit{large}large 的元素个数多了 22 个；

\textit{small}small 比 \textit{large}large 的元素个数少了 11 个。

对于第一种情况，我们将 \textit{small}small 的堆顶元素放入 \textit{large}large；对于第二种情况，我们将 \textit{large}large 的堆顶元素放入 \textit{small}small，这样就可以解决问题了，\texttt{insert(num)}insert(num) 也就设计完成了。

然而对于 \texttt{erase(num)}erase(num) 而言，设计起来就不是那么容易了，因为我们知道，优先队列是不支持移出非堆顶元素这一操作的，因此我们可以考虑使用「延迟删除」的技巧，即：

当我们需要移出优先队列中的某个元素时，我们只将这个删除操作「记录」下来，而不去真的删除这个元素。当这个元素出现在 \textit{small}small 或者 \textit{large}large 的堆顶时，我们再去将其移出对应的优先队列。

「延迟删除」使用到的辅助数据结构一般为哈希表 \textit{delayed}delayed，其中的每个键值对 (\textit{num}, \textit{freq})(num,freq)，表示元素 \textit{num}num 还需要被删除 \textit{freq}freq 次。「优先队列 + 延迟删除」有非常多种设计方式，体现在「延迟删除」的时机选择。在本题解中，我们使用一种比较容易编写代码的设计方式，即：

我们保证在任意操作 \texttt{insert(num)}insert(num)，\texttt{erase(num)}erase(num)，\texttt{getMedian()}getMedian() 完成之后（或者说任意操作开始之前），\textit{small}small 和 \textit{large}large 的堆顶元素都是不需要被「延迟删除」的。这样设计的好处在于：我们无需更改 \texttt{getMedian()}getMedian() 的设计，只需要略加修改 \texttt{insert(num)}insert(num) 即可。

我们首先设计一个辅助函数 \texttt{prune(heap)}prune(heap)，它的作用很简单，就是对 \textit{heap}heap 这个优先队列（\textit{small}small 或者 \textit{large}large 之一），不断地弹出其需要被删除的堆顶元素，并且减少 \textit{delayed}delayed 中对应项的值。在 \texttt{prune(heap)}prune(heap) 完成之后，我们就可以保证 \textit{heap}heap 的堆顶元素是不需要被「延迟删除」的。

这样我们就可以在 \texttt{prune(heap)}prune(heap) 的基础上设计另一个辅助函数 \texttt{makeBalance()}makeBalance()，它的作用即为调整 \textit{small}small 和 \textit{large}large 中的元素个数，使得二者的元素个数满足要求。由于有了 \texttt{erase(num)}erase(num) 以及「延迟删除」，我们在将一个优先队列的堆顶元素放入另一个优先队列时，第一个优先队列的堆顶元素可能是需要删除的。因此我们就可以用 \texttt{makeBalance()}makeBalance() 将 \texttt{prune(heap)}prune(heap) 封装起来，它的逻辑如下：

如果 \textit{small}small 和 \textit{large}large 中的元素个数满足要求，则不进行任何操作；

如果 \textit{small}small 比 \textit{large}large 的元素个数多了 22 个，那么我们我们将 \textit{small}small 的堆顶元素放入 \textit{large}large。此时 \textit{small}small 的对应元素可能是需要删除的，因此我们调用 \texttt{prune(small)}prune(small)；

如果 \textit{small}small 比 \textit{large}large 的元素个数少了 11 个，那么我们将 \textit{large}large 的堆顶元素放入 \textit{small}small。此时 \textit{large}large 的对应的元素可能是需要删除的，因此我们调用 \texttt{prune(large)}prune(large)。

此时，我们只需要在原先 \texttt{insert(num)}insert(num) 的设计的最后加上一步 \texttt{makeBalance()}makeBalance() 即可。然而对于 \texttt{erase(num)}erase(num)，我们还是需要进行一些思考的：

如果 \textit{num}num 与 \textit{small}small 和 \textit{large}large 的堆顶元素都不相同，那么 \textit{num}num 是需要被「延迟删除」的，我们将其在哈希表中的值增加 11；

否则，例如 \textit{num}num 与 \textit{small}small 的堆顶元素相同，那么该元素是可以理解被删除的。虽然我们没有实现「立即删除」这个辅助函数，但只要我们将 \textit{num}num 在哈希表中的值增加 11，并且调用「延迟删除」的辅助函数 \texttt{prune(small)}prune(small)，那么就相当于实现了「立即删除」的功能。

无论是「立即删除」还是「延迟删除」，其中一个优先队列中的元素个数发生了变化（减少了 11），因此我们还需要用 \texttt{makeBalance()}makeBalance() 调整元素的个数。

此时，所有的接口都已经设计完成了。由于 \texttt{insert(num)}insert(num) 和 \texttt{erase(num)}erase(num) 的最后一步都是 \texttt{makeBalance()}makeBalance()，而 \texttt{makeBalance()}makeBalance() 的最后一步是 \texttt{prune(heap)}prune(heap)，因此我们就保证了任意操作完成之后，\textit{small}small 和 \textit{large}large 的堆顶元素都是不需要被「延迟删除」的。

具体实现的细节相对较多，读者可以参考下面的代码和注释进一步理解。

代码

```
class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        DualHeap dh = new DualHeap(k);
        for (int i = 0; i < k; ++i) {
            dh.insert(nums[i]);
        }
        double[] ans = new double[nums.length - k + 1];
        ans[0] = dh.getMedian();
        for (int i = k; i < nums.length; ++i) {
            dh.insert(nums[i]);
            dh.erase(nums[i - k]);
            ans[i - k + 1] = dh.getMedian();
        }
        return ans;
    }
}

class DualHeap {
    // 大根堆，维护较小的一半元素
    private PriorityQueue<Integer> small;
    // 小根堆，维护较大的一半元素
    private PriorityQueue<Integer> large;
    // 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数
    private Map<Integer, Integer> delayed;

    private int k;
    // small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素
    private int smallSize, largeSize;

    public DualHeap(int k) {
        this.small = new PriorityQueue<Integer>(new Comparator<Integer>() {
            public int compare(Integer num1, Integer num2) {
                return num2.compareTo(num1);
            }
        });
        this.large = new PriorityQueue<Integer>(new Comparator<Integer>() {
            public int compare(Integer num1, Integer num2) {
                return num1.compareTo(num2);
            }
        });
        this.delayed = new HashMap<Integer, Integer>();
        this.k = k;
        this.smallSize = 0;
        this.largeSize = 0;
    }

    public double getMedian() {
        return (k & 1) == 1 ? small.peek() : ((double) small.peek() + large.peek()) / 2;
    }

    public void insert(int num) {
        if (small.isEmpty() || num <= small.peek()) {
            small.offer(num);
            ++smallSize;
        } else {
            large.offer(num);
            ++largeSize;
        }
        makeBalance();
    }

    public void erase(int num) {
        delayed.put(num, delayed.getOrDefault(num, 0) + 1);
        if (num <= small.peek()) {
            --smallSize;
            if (num == small.peek()) {
                prune(small);
            }
        } else {
            --largeSize;
            if (num == large.peek()) {
                prune(large);
            }
        }
        makeBalance();
    }

    // 不断地弹出 heap 的堆顶元素，并且更新哈希表
    private void prune(PriorityQueue<Integer> heap) {
        while (!heap.isEmpty()) {
            int num = heap.peek();
            if (delayed.containsKey(num)) {
                delayed.put(num, delayed.get(num) - 1);
                if (delayed.get(num) == 0) {
                    delayed.remove(num);
                }
                heap.poll();
            } else {
                break;
            }
        }
    }

    // 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求
    private void makeBalance() {
        if (smallSize > largeSize + 1) {
            // small 比 large 元素多 2 个
            large.offer(small.poll());
            --smallSize;
            ++largeSize;
            // small 堆顶元素被移除，需要进行 prune
            prune(small);
        } else if (smallSize < largeSize) {
            // large 比 small 元素多 1 个
            small.offer(large.poll());
            ++smallSize;
            --largeSize;
            // large 堆顶元素被移除，需要进行 prune
            prune(large);
        }
    }
}

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/rue6ng/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

复杂度分析

由于「延迟删除」的存在，\textit{small}small 比 \textit{large}large 在最坏情况下可能包含所有的 nn 个元素，即没有一个元素被真正删除了。因此优先队列的大小是 O(n)O(n) 而不是 O(k)O(k) 的，其中 nn 是数组 \textit{nums}nums 的长度。

时间复杂度：O(n\log n)O(nlogn)。\texttt{insert(num)}insert(num) 和 \texttt{erase(num)}erase(num) 的单次时间复杂度为 O(\log n)O(logn)，\texttt{getMedian()}getMedian() 的单次时间复杂度为 O(1)O(1)。因此总时间复杂度为 O(n\log n)O(nlogn)。

空间复杂度：O(n)O(n)。即为 \textit{small}small，\textit{large}large 和 \textit{delayed}delayed 需要使用的空间。

结语
读者可以尝试回答如下的两个问题来检验自己是否掌握了该方法：

在 \texttt{insert(num)}insert(num) 的最后我们加上了一步 \texttt{makeBalance()}makeBalance()，其中包括可能进行的 \texttt{prune(heap)}prune(heap) 操作，这对于 \texttt{insert(num)}insert(num) 操作而言是否是必要的？

在 \texttt{insert(num)}insert(num) 的过程中，如果我们将 \texttt{insert(num)}insert(num) 放入了 \textit{large}large 中，并且 \textit{num}num 恰好出现在 \textit{large}large 的堆顶位置，且两个优先队列的元素个数满足要求，不需要进行调整。此时会不会出现 \textit{num}num 是一个需要被「延迟删除」的元素的情况，这样就不满足在 \texttt{insert(num)}insert(num) 操作完成之后 \textit{large}large 的堆顶是不需要被「延迟删除」的要求了？

答案

是必要的。举个例子：在 \texttt{insert(num)}insert(num) 操作之前，\textit{large}large 的堆顶元素是有效的，但其中第二小的元素是需要被删除的。此时，如果我们将一个很大的元素加入 \textit{large}large 中，并且 \textit{large}large 包含的元素数量超过了 \textit{small}small，那么我们就需要将 \textit{large}large 的堆顶元素放入 \textit{small}small 中。这样一来，\textit{large}large 的堆顶元素就变成了那个需要被删除的第二小的元素了，所以 \texttt{prune(heap)}prune(heap) 操作是必要的。

不可能会出现这种情况，假设出现了这种情况，那么 \textit{num}num 显然不会等于 \textit{large}large 原先的堆顶元素，因为 \textit{large}large 原先的堆顶元素一定是不需要被删除的。那么 \textit{num}num 满足：

\textit{small} ~的堆顶元素 < \textit{num} < \textit{large} ~的堆顶元素
small 的堆顶元素<num<large 的堆顶元素

由于 \textit{small}small 是大根堆，\textit{large}large 是小根堆，因此根本就不存在与 \textit{num}num 值相同的元素，也就不可能会被延迟删除了。

练习：1.存在重复元素 III 2.K 个关闭的灯泡 3.绝对差不超过限制的最长连续子数组

### 链表中的双指针问题

解决链表中的一些问题有些时候需要一些脑洞，并没有那么容易想到。好在这些问题只需要掌握这些常见的技巧就可以了。其中最典型的技巧就是「快慢指针」，也称为「同步指针」。事实上，解决它们都是在链表中使用了两个变量，因此也称为「双指针」技巧。

### 例题：环形链表

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

进阶：

你能用 O(1)O(1)（即，常量）内存解决此问题吗？

示例 1：

![1696685440591](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685440591.png)

 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 

示例 2：

![1696685480185](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685480185.png)


输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：

![1696685496066](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685496066.png)

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
提示：

链表中节点的数目范围是 [0, 104]
-105 <= Node.val <= 105
pos 为 -1 或者链表中的一个 有效索引 。
方法：哈希表
思路及算法

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

代码

JavaC++Python3GolangC

public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while (head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
复杂度分析

时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。

空间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。



### 例题：删除链表的倒数第 N 个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**进阶：** 你能尝试使用一趟扫描实现吗？

![1696685541581](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685541581.png)

输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
示例 2：


输入：head = [1], n = 1
输出：[]
示例 3：


输入：head = [1,2], n = 1
输出：[1]
提示：

链表中结点的数目为 sz
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz

文字题解
前言
在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 \textit{next}next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。

例如，在本题中，如果我们要删除节点 yy，我们需要知道节点 yy 的前驱节点 xx，并将 xx 的指针指向 yy 的后继节点。但由于头节点不存在前驱节点，因此我们需要在删除头节点时进行特殊判断。但如果我们添加了哑节点，那么头节点的前驱节点就是哑节点本身，此时我们就只需要考虑通用的情况即可。

特别地，在某些语言中，由于需要自行对内存进行管理。因此在实际的面试中，对于「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致。下面的代码中默认不释放空间。

方法一：计算链表长度
思路与算法

一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 LL。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n+1L−n+1 个节点时，它就是我们需要删除的节点。

为了与题目中的 nn 保持一致，节点的编号从 11 开始，头节点为编号 11 的节点。

为了方便删除操作，我们可以从哑节点开始遍历 L-n+1L−n+1 个节点。当遍历到第 L-n+1L−n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。

![1696685581026](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685581026.png)

class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        int length = getLength(head);
        ListNode cur = dummy;
        for (int i = 1; i < length - n + 1; ++i) {
            cur = cur.next;
        }
        cur.next = cur.next.next;
        ListNode ans = dummy.next;
        return ans;
    }

    public int getLength(ListNode head) {
        int length = 0;
        while (head != null) {
            ++length;
            head = head.next;
        }
        return length;
    }
}

复杂度分析

时间复杂度：O(L)O(L)，其中 LL 是链表的长度。

空间复杂度：O(1)O(1)。

方法二：栈
思路与算法

我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 nn 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。

class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        Deque<ListNode> stack = new LinkedList<ListNode>();
        ListNode cur = dummy;
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        for (int i = 0; i < n; ++i) {
            stack.pop();
        }
        ListNode prev = stack.peek();
        prev.next = prev.next.next;
        ListNode ans = dummy.next;
        return ans;
    }
}

复杂度分析

时间复杂度：O(L)O(L)，其中 LL 是链表的长度。

空间复杂度：O(L)O(L)，其中 LL 是链表的长度。主要为栈的开销。

方法三：双指针
思路与算法

我们也可以在不预处理出链表的长度，以及使用常数空间的前提下解决本题。

由于我们需要找到倒数第 nn 个节点，因此我们可以使用两个指针 \textit{first}first 和 \textit{second}second 同时对链表进行遍历，并且 \textit{first}first 比 \textit{second}second 超前 nn 个节点。当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 就恰好处于倒数第 nn 个节点。

具体地，初始时 \textit{first}first 和 \textit{second}second 均指向头节点。我们首先使用 \textit{first}first 对链表进行遍历，遍历的次数为 nn。此时，\textit{first}first 和 \textit{second}second 之间间隔了 n-1n−1 个节点，即 \textit{first}first 比 \textit{second}second 超前了 nn 个节点。

在这之后，我们同时使用 \textit{first}first 和 \textit{second}second 对链表进行遍历。当 \textit{first}first 遍历到链表的末尾（即 \textit{first}first 为空指针）时，\textit{second}second 恰好指向倒数第 nn 个节点。

根据方法一和方法二，如果我们能够得到的是倒数第 nn 个节点的前驱节点而不是倒数第 nn 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 \textit{second}second 指向哑节点，其余的操作步骤不变。这样一来，当 \textit{first}first 遍历到链表的末尾时，\textit{second}second 的下一个节点就是我们需要删除的节点。

### 例题：链表的中间结点

给定一个头结点为 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

示例 1：


输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：


输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
提示：

给定链表的结点数介于 1 和 100 之间。

方法一：数组
思路和算法

链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。

C++JavaPython3JavaScript

var middleNode = function(head) {
    let A = [head];
    while (A[A.length - 1].next != null)
        A.push(A[A.length - 1].next);
    return A[Math.trunc(A.length / 2)];
};
复杂度分析

时间复杂度：O(N)O(N)，其中 NN 是给定链表中的结点数目。

空间复杂度：O(N)O(N)，即数组 A 用去的空间。

方法二：单指针法
我们可以对方法一进行空间优化，省去数组 A。

我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。

C++JavaPython3JavaScript

var middleNode = function(head) {
    n = 0;
    cur = head;
    while (cur != null) {
        ++n;
        cur = cur.next;
    }
    k = 0;
    cur = head;
    while (k < Math.trunc(n / 2)) {
        ++k;
        cur = cur.next;
    }
    return cur;
};
复杂度分析

时间复杂度：O(N)O(N)，其中 NN 是给定链表的结点数目。

空间复杂度：O(1)O(1)，只需要常数空间存放变量和指针。

方法三：快慢指针法
思路和算法

我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。

C++JavaPython3JavaScript

var middleNode = function(head) {
    slow = fast = head;
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
};
复杂度分析

时间复杂度：O(N)O(N)，其中 NN 是给定链表的结点数目。

空间复杂度：O(1)O(1)，只需要常数空间存放 slow 和 fast 两个指针。

练习： 1.环形链表 II 2.相交链表



### 双指针：相向交替移动的两个变量

相向交替移动的两个变量
「双指针」是指通过两个变量交替相向移动完成任务的算法，具体来说，可以使用两个变量 i 和 j ，初始的时候，i 和 j 分别指向数组的第一个元素和最后一个元素，然后指针 i 不断向右移动， 指针 j 不断向左移动，直到它们相遇。这样设计的算法少考虑了很多暴力解法需要考虑的情况，如下图所示。

![1696685780987](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685780987.png)

 我们依然是通过例子向大家展示「双指针」算法 的应用。 

![1696685800386](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685800386.png)

方法一：暴力解法
JavaPython3

public class Solution {

    public int maxArea(int[] height) {
        int len = height.length;
        if (len < 2) {
            return 0;
        }
        int res = 0;
        for (int i = 0; i < len - 1; i++) {
            for (int j = i + 1; j < len; j++) {
                res = Math.max(res, Math.min(height[i], height[j]) * (j - i));
            }
        }
        return res;
    }
}
暴力解法的时间复杂度太高，我们可以使用指针对撞的方法降低时间复杂度。

方法二：双指针
下面的动画演示了「双指针」算法作用于示例 1 的计算过程：

![1696685860251](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685860251.png)

![1696685875043](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685875043.png)

![1696685887813](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685887813.png)

![1696685904620](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685904620.png)

![1696685919851](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685919851.png)

![1696685934498](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685934498.png)

![1696685947562](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685947562.png)

![1696685960483](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696685960483.png)

参考代码：

JavaPython3

public class Solution {

    public int maxArea(int[] height) {
        int len = height.length;
        if (len < 2) {
            return 0;
        }
    
        int left = 0;
        int right = len - 1;
    
        int res = 0;
        while (left < right) {
            int minHeight = Math.min(height[left], height[right]);
            res = Math.max(res, minHeight * (right - left));
    
            if (height[left] == minHeight) {
                left++;
            } else {
                right--;
            }
        }
        return res;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，双指针总计最多遍历整个数组一次；
空间复杂度：O(1)O(1)，只需要额外的常数级别的空间。
本题总结：「双指针」算法和「滑动窗口」算法一样，都是基于 特定的问题 对 暴力解法 进行的优化，少考虑了很多不必要的情况，使得时间复杂度达到线性级别。

### 例题：两数之和 II - 输入有序数组

给定一个已按照 升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2*。*

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:


输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

题意分析：

这道题可以使用「1. 两数之和」的解法，使用 O(n^2)O(n 
2
 ) 的时间复杂度和 O(1)O(1) 的空间复杂度暴力求解，或者借助哈希表使用 O(n)O(n) 的时间复杂度和 O(n)O(n) 的空间复杂度求解。但是这两种解法都是针对无序数组的，没有利用到输入数组有序的性质。利用输入数组有序的性质，可以得到时间复杂度和空间复杂度更优的解法。

联系两数之和第 1 题，可以使用哈希表也是可以的，不过哈希表的方法没有用到数组的有序性；
看到有序，首先可以想到使用「二分查找」。但是我们这题，用「指针对撞」更合适。
初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。

使用双指针的实质是缩小查找范围。那么会不会把可能的解过滤掉？答案是不会。假设 \text{numbers}[i]+\text{numbers}[j]=\text{target}numbers[i]+numbers[j]=target 是唯一解，其中 0 \leq i<j \leq \text{numbers.length}-10≤i<j≤numbers.length−1。初始时两个指针分别指向下标 00 和下标 \text{numbers.length}-1numbers.length−1，左指针指向的下标小于或等于 ii，右指针指向的下标大于或等于 jj。除非初始时左指针和右指针已经位于下标 ii 和 jj，否则一定是左指针先到达下标 ii 的位置或者右指针先到达下标 jj 的位置。

如果左指针先到达下标 ii 的位置，此时右指针还在下标 jj 的右侧，\text{sum}>\text{target}sum>target，因此一定是右指针左移，左指针不可能移到 ii 的右侧。

如果右指针先到达下标 jj 的位置，此时左指针还在下标 ii 的左侧，\text{sum}<\text{target}sum<target，因此一定是左指针右移，右指针不可能移到 jj 的左侧。

由此可见，在整个移动过程中，左指针不可能移到 ii 的右侧，右指针不可能移到 jj 的左侧，因此不会把可能的解过滤掉。由于题目确保有唯一的答案，因此使用双指针一定可以找到答案。

参考代码：

JavaPython3

public class Solution {

    public int[] twoSum(int[] numbers, int target) {
        int len = numbers.length;
        int left = 0;
        int right = len - 1;
    
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum == target) {
                return new int[]{left + 1, right + 1};
            } else if (sum > target) {
                right--;
            } else {
                left++;
            }
        }
        return new int[]{-1, -1};
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，其中 NN 是数组的长度。两个指针移动的总次数最多为 NN 次；
空间复杂度：O(1)O(1)。

### 例题：三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：


输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：


输入：nums = []
输出：[]
示例 3：


输入：nums = [0]
输出：[]
提示：

0 <= nums.length <= 3000
-10^5 <= nums[i] <= 10^5

本题与 1. 两数之和 类似，是非常经典的面试题，但是做法不尽相同。

题目中要求找到所有「不重复」且和为 00 的三元组，这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组。这是因为在最坏的情况下，数组中的元素全部为 00，即


[0, 0, 0, 0, 0, ..., 0, 0, 0]
任意一个三元组的和都为 00。如果我们直接使用三重循环枚举三元组，会得到 O(N^3)O(N 
3
 ) 个满足题目要求的三元组（其中 NN 是数组的长度）时间复杂度至少为 O(N^3)O(N 
3
 )。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。

「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：

第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；

第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。

也就是说，我们枚举的三元组 (a, b, c)(a,b,c) 满足 a \leq b \leq ca≤b≤c，保证了只有 (a, b, c)(a,b,c) 这个顺序会被枚举到，而 (b, a, c)(b,a,c)、(c, b, a)(c,b,a) 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。

同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为


[0, 1, 2, 2, 2, 3]
 ^  ^  ^
我们使用三重循环枚举到的第一个三元组为 (0, 1, 2)(0,1,2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0, 1, 2)(0,1,2)，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 33，枚举三元组 (0, 1, 3)(0,1,3)。

下面给出了改进的方法的伪代码实现：


nums.sort()
for first = 0 .. n-1
    // 只有和上一次枚举的元素不相同，我们才会进行枚举
    if first == 0 or nums[first] != nums[first-1] then
        for second = first+1 .. n-1
            if second == first+1 or nums[second] != nums[second-1] then
                for third = second+1 .. n-1
                    if third == second+1 or nums[third] != nums[third-1] then
                        // 判断是否有 a+b+c==0
                        check(first, second, third)
这种方法的时间复杂度仍然为 O(N^3)O(N 
3
 )，毕竟我们还是没有跳出三重循环的大框架。然而它是很容易继续优化的，可以发现，如果我们固定了前两重循环枚举到的元素 aa 和 bb，那么只有唯一的 cc 满足 a+b+c=0a+b+c=0。当第二重循环往后枚举一个元素 b'b 
′
  时，由于 b' > bb 
′
 >b，那么满足 a+b'+c'=0a+b 
 >′
 > +c 
 >′
 > =0 的 c'c 
 >′
 >  一定有 c' < cc 
 >′
 > <c，即 c'c 
 >′
 >  在数组中一定出现在 cc 的左侧。也就是说，我们可以从小到大枚举 bb，同时从大到小枚举 cc，即第二重循环和第三重循环实际上是并列的关系。

有了这样的发现，我们就可以保持第二重循环不变，而将第三重循环变成一个从数组最右端开始向左移动的指针，从而得到下面的伪代码：


nums.sort()
for first = 0 .. n-1
    if first == 0 or nums[first] != nums[first-1] then
        // 第三重循环对应的指针
        third = n-1
        for second = first+1 .. n-1
            if second == first+1 or nums[second] != nums[second-1] then
                // 向左移动指针，直到 a+b+c 不大于 0
                while nums[first]+nums[second]+nums[third] > 0
                    third = third-1
                // 判断是否有 a+b+c==0
                check(first, second, third)
这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2)O(N 
2
 ) 减少至 O(N)O(N)。为什么是 O(N)O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 bb），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)O(N)。

注意到我们的伪代码中还有第一重循环，时间复杂度为 O(N)O(N)，因此枚举的总时间复杂度为 O(N^2)O(N 
2
 )。由于排序的时间复杂度为 O(N \log N)O(NlogN)，在渐进意义下小于前者，因此算法的总时间复杂度为 O(N^2)O(N 
2
 )。

上述的伪代码中还有一些细节需要补充，例如我们需要保持左指针一直在右指针的左侧（即满足 b \leq cb≤c），具体可以参考下面的代码，均给出了详细的注释。

```
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        // 枚举 a
        for (int first = 0; first < n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second < n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    List<Integer> list = new ArrayList<Integer>();
                    list.add(nums[first]);
                    list.add(nums[second]);
                    list.add(nums[third]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/od7qht/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

复杂度分析

时间复杂度：O(N^2)O(N 
2
 )，其中 NN 是数组 \textit{nums}nums 的长度。

空间复杂度：O(\log N)O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(\log N)O(logN)。然而我们修改了输入的数组 \textit{nums}nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 \textit{nums}nums 的副本并进行排序，空间复杂度为 O(N)O(N)。



### 例题：验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:


输入: "A man, a plan, a canal: Panama"
输出: true
示例 2:


输入: "race a car"
输出: false

思路分析：我们可以对方法一中第二种判断回文串的方法进行优化，就可以得到只使用 O(1)O(1) 空间的算法。

我们直接在原字符串 ss 上使用双指针。在移动任意一个指针时，需要不断地向另一指针的方向移动，直到遇到一个字母或数字字符，或者两指针重合为止。也就是说，我们每次将指针移到下一个字母字符或数字字符，再判断这两个指针指向的字符是否相同。

参考代码：

JavaPython3

public class Solution {

    public boolean isPalindrome(String s) {
        int len = s.length();
        // 如果字符只有 1 个字母，那么也一定是回文数
        if (len < 2) {
            return true;
        }
    
        // 只考虑字母和数字字符，可以忽略字母的大小写。
        s = s.toLowerCase();
        // 只保留小写字母和数字
        s = s.replaceAll("[^0-9a-z]", "");
        char[] charArray = s.toCharArray();
        int left = 0;
        int right = charArray.length - 1;
        while (left < right) {
            char leftChar = charArray[left];
            char rightChar = charArray[right];
            if (leftChar != rightChar) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
复杂度分析：

时间复杂度：O(|s|)O(∣s∣)，其中 |s|∣s∣ 是字符串 ss 的长度；
空间复杂度：O(1)O(1)。

### 例题：反转字符串

题目描述
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：


输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：


输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
📖 文字题解
思路分析：对于长度为 N 的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为 s[0] s[1] s[2] ... s[N - 1]，那么反转后字符数组为 s[N - 1] s[N - 2] ... s[0]。比较反转前后下标变化很容易得出 s[i] 的字符与 s[N - 1 - i] 的字符发生了交换的规律，因此我们可以得出如下双指针的解法：

将 left 指向字符数组首元素，right 指向字符数组尾元素。
当 left < right：
交换 s[left] 和 s[right]；
left 指针右移一位，即 left = left + 1；
right 指针左移一位，即 right = right - 1。
当 left >= right，反转结束，返回字符数组即可。

![1696686149363](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696686149363.png)

public class Solution {

    public String reverseString(char[] s) {
        int len = s.length;
    
        int left = 0;
        int right = len - 1;
        while (left < right) {
            swap(s, left, right);
            left++;
            right--;
        }
        return new String(s);
    }
    
    private void swap(char[] s, int index1, int index2) {
        char temp = s[index1];
        s[index1] = s[index2];
        s[index2] = temp;
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，其中 NN 为字符数组的长度。一共执行了 \cfrac{N}{2} 
2
N

  次交换；
空间复杂度：O(1)O(1)。只使用了常数空间来存放若干变量。

### 例题：反转字符串中的元音字母

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:


输入: "hello"
输出: "holle"
示例 2:


输入: "leetcode"
输出: "leotcede"
说明:

元音字母不包含字母"y"。
参考代码：

JavaPython3

public class Solution {

    public String reverseVowels(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        char[] charArray = s.toCharArray();
        int left = 0;
        int right = len - 1;
        while (true) {
            while (left < len && checkVowels(charArray[left])) {
                left++;
            }
            while (right >= 0 && checkVowels(charArray[right])) {
                right--;
            }
            if (left < right) {
                swap(charArray, left, right);
                left++;
                right--;
            } else {
                break;
            }
        }
        return new String(charArray);
    }
    
    private void swap(char[] chars, int index1, int index2) {
        char temp = chars[index1];
        chars[index1] = chars[index2];
        chars[index2] = temp;
    }
    
    private boolean checkVowels(char c) {
        return c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&
                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U';
    }
}
复杂度分析：

时间复杂度：O(N)O(N)，其中 NN 为字符数组的长度。一共执行了 \cfrac{N}{2} 
2
N

  次交换；
空间复杂度：O(1)O(1)。只使用了常数空间来存放若干变量。


![1696686218956](C:\Users\gsz\AppData\Roaming\Typora\typora-user-images\1696686218956.png)

不管是「滑动窗口」还是「双指针」问题，其实都是在完成任务的过程中使用了一些变量帮助我们以线性时间复杂度完成题目交给的任务，理解它们基于对问题本身的理解，大家在做题的过程中需要体会这两种算法都是对暴力解法的优化。这一专题的内容并不难，但是掌握好它们需要一定量的练习，最好的办法也是看起来最笨的办法。我们给出一些学习过程中的建议。

画图分析；
通过具体的、恰当的例子归纳解题思路；
遇到问题的时候一定不能急躁，在代码中打印出变量中的值，观察变量的值是不是按照我们设计的逻辑进行的，这样的办法也是最有效的办法；
理解「循环不变量」，并利用好「循环不变量」，这个非常朴素的、在写对代码的过程中一定需要保证的性质。




